# 架构师思维设计架构

## 1. 设计模式

对修改关闭，对扩展开放
多态

### 1.1 单例模式Singleton

**目的：对象只被创建一次。**
1. 懒汉式，双重判断，synchronized影响了效率
2. 静态内部方式，jvm保证只会加载一次
3. 枚举方式，解决同步，防止反序列化，因为`枚举类没有构造方法`
  
```java
package com.xuzhihao.design.mode.singleton;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * 使用单例模式创建JDBC工具类 构造器私有化，自行创建实例，自行向系统提供这个实例
 */
//饿汉式：直接创建对象 不存在线程安全问题
//	 直接实例化
//	 枚举式
//	 静态代码块
//懒汉式：延迟创建对象
//	线程不安全 适用于单线程
//	线程安全 适用于多线程
//	静态内部类 适用于多线程
public final class JdbcUtilsSingleton {

	private static ThreadLocal<Connection> tl = new ThreadLocal<>();

	private static final String driver = "com.mysql.cj.jdbc.Driver";// mysql驱动
//	private static final String driver = "oracle.jdbc.driver.OracleDriver"; // oracle驱动
//	private static final String driver = "org.postgresql.Driver"; // postgresql驱动
//	private static final String driver = "com.microsoft.sqlserver.jdbc.SQLServerDriver"; // sqlserver驱动

	private static final String url = "jdbc:mysql://debug-registry:3306/mall";// mysql地址
//	private static final String url = "jdbc:oracle:thin:@debug-registry:1521:ORCL"; // oracle地址
//	private static final String url = "jdbc:postgresql://debug-registry:5432/VJSP10003182"; // postgresql地址
//	private static final String url = "jdbc:sqlserver://debug-registry:1433; DatabaseName=maptest"; // sqlserver地址

	private String username = "root";
	private String password = "root";

	// 懒汉式单例
	private static JdbcUtilsSingleton singleton;

	/**
	 * 构造器私用,防止直接创建对象, 通过反射或反序列化可以破解单例
	 */
	private JdbcUtilsSingleton() {

	}

	public static JdbcUtilsSingleton getInstance() {
		if (singleton == null) {
			// 加入有一个线程走到这里,然后又然给另一个线程执行完
			synchronized (JdbcUtilsSingleton.class) {
				if (singleton == null) {
					singleton = new JdbcUtilsSingleton();
				}
			}
		}
		return singleton;
	}

	static {
		try {
			Class.forName(driver);
		} catch (ClassNotFoundException e) {
			throw new ExceptionInInitializerError(e);
		}
	}

	/**
	 * 获取连接
	 * 
	 * @return
	 * @throws SQLException
	 */
	public synchronized Connection getConnection() throws SQLException {
		Connection conn = tl.get();
		// 如果容器中没有连接，就从连接池获取一个连接存到ThreadLocal中
		if (conn == null) {
			conn = DriverManager.getConnection(url, username, password);
			tl.set(conn);
		}
		return conn;
	}

	/**
	 * 释放资源
	 */
	public static void free(AutoCloseable... ios) {
		for (AutoCloseable io : ios) {
			try {
				if (io != null) {
					io.close();
				}
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				try {
					if (io != null) {
						io.close();
					}
				} catch (Exception e) {
					e.printStackTrace();
				} finally {
					if (io != null) {
						try {
							io.close();
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
			}
		}
	}
}
```

```java
package com.xuzhihao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import com.xuzhihao.design.mode.singleton.JdbcUtilsSingleton;

public class JdbcTest {
	public static void main(String[] args) throws SQLException {

		// 首先需要获取实例,然后获取连接
		Connection conn = JdbcUtilsSingleton.getInstance().getConnection();
		// 创建语句
		Statement st = conn.createStatement();
		// 执行语句
		ResultSet rs = st.executeQuery("select * from ums_admin");
		// 处理结果集
		while (rs.next()) {
			System.out.println(
					rs.getObject(1) + "\t" + rs.getObject(2) + "\t" + rs.getObject(3) + "\t" + rs.getObject(4));
		}
		st.executeBatch();
		st.close();

		//批量插入
		String sql = "INSERT INTO ums_admin2 (username,password) VALUES(?,?)";
		PreparedStatement pstmt = conn.prepareStatement(sql);
		for (int i = 1; i <= 10; i++) {
			pstmt.setString(1, "username" + i);
			pstmt.setString(2, "password" + i);
			pstmt.addBatch();
		}
		pstmt.executeBatch();
		pstmt.close();
		conn.close();
	}
}
```
```java
/**
 * 静态内部类方式 JVM保证单例
 */
public class Sington {
	private Sington() {

	}

	private static class SingtonHolder {
		private final static Sington INSTANCE = new Sington();
	}

	public static Sington getInstance() {
		return SingtonHolder.INSTANCE;
	}

	public static void main(String[] args) {
		for (int i = 0; i < 10; i++) {
			new Thread(() -> {
				System.out.println(Sington.getInstance().hashCode());
			}).start();
		}
	}
}
```
```java
public enum Sington {

	INSTANCE;

	public static void main(String[] args) {
		for (int i = 0; i < 10; i++) {
			new Thread(() -> {
				System.out.println(Sington.INSTANCE.hashCode());
			}).start();
		}
	}
}
```

### 1.2 策略模式Strategy

Comparator实现子类实现比较大小

坦克大战不同子弹采取不同策略

### 1.3 工厂方法模式

- 工厂方法
- 抽象工厂

产生对象的类和方法都可以叫做工厂，目的是灵活控制生产过程

### 原型模式



### 抽象工厂模式

### 建造者模式

### 结构型模式

### 代理模式

### 适配器模式
- tomcat CoyoteAdapter

### 桥接模式

### 装饰模式

### 外观模式

### 享元模式

### 组合模式

### 行为型模式

### 模板方法模式
- tomcat LifecycleBase initInternal startInternal



### 命令模式

### 责任链模式

### 状态模式

### 观察者模式

### 中介者模式

### 迭代器模式

### 访问者模式

### 备忘录模式

### 解释器模式


## 2. 架构设计

## 3. 领域驱动模型DDD